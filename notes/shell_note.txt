----------------------------------------------------------------------------------------------------------------------------
正则表达式：
常用的正则表达式grep sed awk 
linux的正则表达式和命令行中其他的命令使用统配符有区别
linux 正则表达式一般以行为单位
alias grep='grep --color=auto'
注意字符集，LC_ALL=C
基础正则表达式：
1) ^word 表示搜索以word开头的内容
2）word$ 表示搜索以word结尾的内容
3)^$表示空行
4). 代表且只能代表任意一个字符 
5)\ 转义字符
6)* 重复0个或多个前面的一个字符，不代表所有(此时*不是统配符)
7).* 匹配所有的字符 ^.* 任意多个字符开头
8)[abc] 匹配字符集合内任意一个字符[a-z]
9)[^abc] 表示取反，表示不包含a或b或c的内容
10){n,m}表示重复n到m次，前一个字符
    {n,} 至少n次，多了不限
    {n} n次
    {,m} 至多m次，少了不限
   注:grep 要多{}进行转义\{\}，egrep 不需要转义了
   egrep ==grep -E
grep 命令：
-v 排除匹配的内容
-E 支持扩展的正则表达式
-i 忽略大小写
-o 输出匹配的字符
--color=auto 匹配的内容显示颜色
-n 显示行号
sed:
s 替换
g全局替换
-i 修改文件
-n 取消默认输出
p 打印内容
过滤IP地址和广播地址：
ifconfig eth0 | sed -n 's/^.*dr:\(.*\) B.*t:\(.*\)  Ma.*$/\1\2/gp'
ifconfig eth0 | grep 'inet addr' | awk -F '[: ]+' '{print $4}'
ifconfig eth0 |sed -n '2p'|awk -F '[: ]+' '{print $4}'
ifconfig eth0 | awk -F '[: ]+' 'NR==2 {print $4}'    //NR表示第几行
扩展正则表达式：egrep/grep -E
1) + 重复一个或一个以上前面
2) ? 重复0个或一个0前面的字符
3) | 用或的方式查找多个符合的字符串
4)()找出'用户组'字符
awk
NR 行号
NF 当前记录域或列的个数
$NF 代表最后一列
[root@Linux shell]# stat /etc/passwd
  File: `/etc/passwd'
  Size: 1517            Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 533456      Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2015-05-30 01:19:01.814999984 +0800
Modify: 2015-05-17 18:30:55.233764056 +0800
Change: 2015-05-17 18:30:55.235763056 +0800
-------------------------------------------------------------------------------------------------------------------------
1.关闭不必要的服务
ntsysv chkconfig
必须开启的服务有： crond/messagebus/network/iptables/sshd/syslog/sysstat/snmpd
关闭不必要的服务脚本：
for i in `chkconfig --list |awk '/3:on/ {print $1}'|grep -v "crond\| messagebus\|sshd\|iptables\|network\|syslog\|snmpd\|sysstat"`; 
do  chkconfig --level 345 ${i} off; 
done
开启需要的服务脚本：
for i in "crond" "messagebus" "iptables" "network" "snmpd" "sshd"  "syslog" "sysstat";
do  chkconfig --level 345 ${i} on; 
done
3.检查服务的基本配置
dmidecode | grep "Product" | head -n 1  检查服务器型号
cat /proc/cpuinfo | grep name | cut -f2 -d: |uniq -c 检查CUP信号
free -m | grep Mem | awk '{print $2}'
ifconfig | grep "inet addr" | awk -F: '{print $2}'| awk '{print $1}'
4.系统优化修改/etc/sysctl.conf文件，sysctl -p 是修改生效；
关闭不必要的服务使用ntsysv;查看自启动服务chkconfig;
5.修改系统的文件句柄书/etc/security/limits.conf   确认句柄允许数据ulimit -n
6.修改sshd监听端口，并禁止密码验证登录配置文件/etc/ssh/sshd_config
7.账号安全，清除除root用户之外的其他用户的登录权限
     #!/bin/bash
    for k in `cat /etc/passwd | grep -i "\/bin\/bash" | grep -v "root" | cut -d: -f1`;
    do
    usermod -s /sbin/nologin ${k};
    done
    更改root用户密码：
    echo "xxxxxxxx" >/root/tmp.txt   “xxxxxxxx”为设定的密码
    passwd root --stdin </root/tmp.txt ；rm –f /root/tmp.txt
8.查看系统的基本信息脚本
    #!/bin/bash
    dmidecode | grep "Product" | head -n 1
    cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c
    free -m | grep Mem | awk '{print $2}'
    ifconfig | grep "inet addr" | awk -F: '{print $2}'| awk '{print $1}'
    route -n 
    cat /etc/issue | head -n 1
    uname -a
    df -h | awk '{print $1,$2}'
9.加载ext4模块
    modprobe ext4
    lsmod | grep ext4
    yum -y install e4fsprogs
10.统计登陆用户数
uptime | cut -d',' -f 2 | sed 's/^[[:space:]]*//g'
who | wc -l 
11.添加用户脚本
#!/bin/bash
id $1 >/dev/null 2>&1
if [ $? -eq 0 ];then
        echo "$1 is exsit!"
else
        useradd $1
        echo "123456" | passwd --stdin "$1" >/dev/null 2>&1
        if [ $? -eq 0 ];then
                echo "$1 create seccuss!"
        fi
fi
12.Shell 脚本中有个变量叫IFS(Internal Field Seprator) ，内部域分隔符,当 shell 处理"命令替换"和"参数替换"时，shell 根据 IFS 的值，默认是 space, tab, newline 来拆解读入的变量，然后对特殊字符进行处理，最后重新组合赋值给该变量
实际应用
#!/bin/bash
OLD_IFS=$IFS #保存原始值
IFS="" #改变IFS的值
...
...
IFS=$OLD_IFS #还原IFS的原始值
正在运行的内核和系统信息
# uname -a # 获取内核版本（和BSD版本）
# lsb_release -a # 显示任何 LSB 发行版版本信息
# cat /etc/SuSE-release # 获取 SuSE 版本
# uptime # 显示系统开机运行到现在经过的时间
# hostname # 显示系统主机名
# hostname -i # 显示主机的 IP 地址
# man hier # 描述文件系统目录结构
# last reboot # 显示系统最后重启的历史记录
硬件信息
内核检测到的硬件信息
# dmesg # 检测到的硬件和启动的消息
# lsdev # 关于已安装硬件的信息
# dd if=/dev/mem bs=1k skip=768 count=256 2>/dev/null | strings -n 8 # 读取 BIOS 信息
Linux

# cat /proc/cpuinfo                  # CPU 讯息
# cat /proc/meminfo                  # 内存信息
# grep MemTotal /proc/meminfo        # 显示物理内存大小
# watch -n1 'cat /proc/interrupts'   # 监控内核处理的所有中断
# free -m                            # 显示已用和空闲的内存信息 (-m 为 MB)
# cat /proc/devices                  # 显示当前核心配置的设备
# lspci -tv                          # 显示 PCI 设备
# lsusb -tv                          # 显示 USB 设备
# lshal                              # 显示所有设备属性列表
# dmidecode                          # 显示从 BIOS 中获取的硬件信息

显示状态信息
以下的命令有助于找出正在系统中运行着的程序。

# top                                # 显示和更新使用 cpu 最多的进程
# mpstat 1                           # 显示进程相关的信息
# vmstat 2                           # 显示虚拟内存的状态信息
# iostat 2                           # 显示 I/O 状态信息(2 秒 间隙)
# tail -n 500 /var/log/messages      # 显示最新500条内核/系统日志的信息
# tail /var/log/warn                 # 显示系统警告信息(看syslog.conf) 

用户

# id                                 # 显示当前用户和用户组的 ID
# last                               # 列出目前与过去登入系统的用户相关信息
# who                                # 显示目前登入系统的用户信息
# groupadd admin                     # 建立新组"admin"和添加新用户 colin 并加入 admin 用户组(Linux/Solaris)
# useradd -c "Colin Barschel" -g admin -m colin
# userdel colin                      # 删除用户 colin(Linux/Solaris)
# adduser joe                        # FreeBSD 添加用户 joe(交互式)
# rmuser joe                         # FreeBSD 删除用户 joe(交互式)
# pw groupadd admin                  # 在 FreeBSD 上使用 pw
# pw groupmod admin -m newmember     # 添加新用户到一个组
# pw useradd colin -c "Colin Barschel" -g admin -m -s /bin/tcsh 
# pw userdel colin; pw groupdel admin 

加密过的密码存储在 /etc/shadow (Linux and Solaris) 
使用 nologin 来临时阻止所有用户登录(root除外)。用户登录时将会显示 nologin 中的信息。

# echo "Sorry no login now" > /etc/nologin       # (Linux) 

限制
某些应用程序需要设置可打开最大文件和 socket 数量(像代理服务器，数据库)。 默认限制通常很低。
Linux
每 shell/脚本
shell 的限制是受 ulimit 支配的。使用 ulimit -a 可查看其状态信息。 举个例子，改变可打开最大文件数从 1024 到 10240，可以这么做：

# ulimit -n 10240                    # 这只在shell中有用 

ulimit 命令可以使用在脚本中来更改对此脚本的限制。
每 用户/进程
登录用户和应用程序的限制可以在 /etc/security/limits.conf 中配置。举个例子：

# cat /etc/security/limits.conf
*   hard    nproc   250              # 限制所有用户进程数
asterisk hard nofile 409600          # 限制应用程序可打开最大文件数 

系统级
用sysctl来设置内核限制。要使其永久，可以在 /etc/sysctl.conf 中进行配置。

# sysctl -a                          # 显示所有系统限制
# sysctl fs.file-max                 # 显示系统最大文件打开数
# sysctl fs.file-max=102400          # 更改系统最大文件打开数
# cat /etc/sysctl.conf
fs.file-max=102400                   # 在 sysctl.conf 中的永久项
# cat /proc/sys/fs/file-nr           # 在使用的文件句柄数

运行级别
Linux
一旦内核加载完成，内核会启动 init 进程，然后运行 rc 脚本，之后运行所有属于其运行级别的命令脚本。这些脚本都储存在 /etc/rc.d/rcN.d 中(N代表运行级别)，并且都建立着到 /etc/init.d 子目录中命令脚本程序的符号链接。
默认运行级别配置在 /etc/inittab 中。它通常为 3 或 5：

# grep default: /etc/inittab                                         
id:3:initdefault: 

可以使用 init 来改变当前运行级别。举个例子：

# init 5                             # 进入运行级别 5

运行级别列表如下：
    - 0       系统停止
    - 1       进入单用户模式(也可以是 S)
    - 2       没有 NFS 特性的多用户模式
    - 3       完全多用户模式(正常操作模式)
    - 4       未使用
    - 5       类似于级别3，但提供 XWindow 系统登录环境
    - 6       重新启动系统
使用 chkconfig 工具控制程序在一个运行级别启动和停止。

# chkconfig --list                   # 列出所有 init 脚本
# chkconfig --list sshd              # 查看 sshd 在各个运行级别中的启动配置
# chkconfig sshd --level 35 on       # 对 sshd 在级别 3 和 5 下创建启动项
# chkconfig sshd off                 # 在所有的运行级别下禁用 sshd

重设 root 密码
Linux 方法 1
在引导加载器(lilo 或 grub)中，键入如下启选项：

init=/bin/sh

内核会挂载 root 分区，进程 init 会启动 bourne shell 而不是 rc，然后是运行级别。使用命令 passwd 设置密码然后重启。别忘了需要在单用户模式下做这些动作。
如果重启后 root 分区被挂载为只读，重新挂在它为读写：

# mount -o remount,rw /
# passwd                             # 或者删除 root 密码 (/etc/shadow)
# sync; mount -o remount,ro /        # sync 在重新挂在为只读之前 sync 一下
# reboot 

内核模块
Linux

# lsmod                              # 列出所有已载入内核的模块
# modprobe isdn                      # 载入 isdn 模块

编译内核
Linux

# cd /usr/src/linux
# make mrproper                      # 清除所有东西，包括配置文件
# make oldconfig                     # 从当前内核配置文件的基础上创建一个新的配置文件
# make menuconfig                    # 或者 xconfig (Qt) 或者 gconfig (GTK)
# make                               # 创建一个已压缩的内核映像文件
# make modules                       # 编译模块
# make modules_install               # 安装模块
# make install                       # 安装内核
# reboot 

要重建完全的操作系统：

# make buildworld                    # 构建完全的系统，但不是内核
# make buildkernel                   # 使用 KERNCONF 配置文件编译内核
# make installkernel
# reboot
# mergemaster -p                     # 建立临时根环境并比对系统配置文件
# make installworld
# mergemaster                        # 升级所有配置和其他文件
# reboot 

对于源的一些小改动，有时候简单的命令就足够了：

# make kernel world                  # 编译并安装内核和系统
# mergemaster
# reboot 

进程

列表 | 优先级 | 后台/前台 | Top | Kill
进程列表
PID是每个进程唯一号码。使用 ps 获取所有正在运行的进程列表。

# ps -auxefw                         # 所有正在运行进程的详尽列表

然而，更典型的用法是使用管道或者 pgrep:

# ps axww | grep cron
  586  ??  Is     0:01.48 /usr/sbin/cron -s
# ps aux | grep 'ss[h]'              # Find all ssh pids without the grep pid
# pgrep -l sshd                      # 查找所有进程名中有sshd的进程ID
# echo $$                            # The PID of your shell
# fuser -va 22/tcp                   # 列出使用端口22的进程
# fuser -va /home                    # 列出访问 /home 分区的进程
# strace df                          # 跟踪系统调用和信号
# truss df                           # 同上(FreeBSD/Solaris/类Unix)
# history | tail -50                 # 显示最后50个使用过的命令 

优先级
用 renice 更改正在运行进程的优先级。负值是更高的优先级，最小为-20，其正值与 "nice" 值的意义相同。

# renice -5 586                      # 更强的优先级
586: old priority 0, new priority -5 

使用 nice 命令启动一个已定义优先级的进程。 正值为低优先级，负值为高优先级。确定你知道 /usr/bin/nice 或者使用 shell 内置命令(# which nice)。

# nice -n -5 top                     # 更高优先级(/usr/bin/nice)
# nice -n 5 top                      # 更低优先级(/usr/bin/nice)
# nice +5 top                        # tcsh 内置 nice 命令(同上) 

nice 可以影响 CPU 的调度，另一个实用命令 ionice 可以调度磁盘 IO。This is very useful for intensive IO application which can bring a machine to its knees while still in a lower priority. 此命令仅可在 Linux (AFAIK) 上使用。你可以选择一个类型(idle - best effort - real time)，它的 man 页很短并有很好的解释。

# ionice c3 -p123                    # 给 pid 123 设置为 idle 类型
# ionice -c2 -n0 firefox             # 用 best effort 类型运行 firefox 并且设为高优先级
# ionice -c3 -p$$                    # 将当前的进程(shell)的磁盘 IO 调度设置为 idle 类型 

例中最后一条命令对于编译(或调试)一个大型项目会非常有用。每一个运行于此 shell 的命令都会有一个较低的优先级，但并不妨碍这个系统。$$ 是你 shell 的 pid (试试 echo $$)。
前台/后台
当一个进程在 shell 中已运行，可以使用 [Ctrl]-[Z] (^Z), bg 和 fg 来 调入调出前后台。举个例子：启动 2 个进程，调入后台。使用 jobs 列出后台列表，然后再调入一个进程到前台。

# ping cb.vu > ping.log
^Z                                   # ping 使用 [Ctrl]-[Z] 来暂停(停止) 
# bg                                 # 调入后台继续运行
# jobs -l                            # 后台进程列表
[1]  - 36232 Running                       ping cb.vu > ping.log
[2]  + 36233 Suspended (tty output)        top
# fg %2                              # 让进程 2 返回到前台运行

read 可以一次读取所有的值到多个变量，一$IFS里的字符为分隔输入行里的数据
当使用read -r 参数时，read不会将结尾的反斜线视为特殊字符
重定向：file > results 2>errors         //把标准错误输出信息放到erros文件里
        file > results 2> /dev/null     //丢弃标准错误输出的信息
        file > results 2>&1            //标准输出和标准错误输出信息都放到results文件里
在shell脚本里，对于临时性文件一般是通过$$进程号进行命令文件
查找文件可以是locate，find
locate是将文件系统的所有文件名压缩成数据库，以迅速找到匹配shell通配符的文件
寻找命令存储位置  type
/dev/random 和/dev/urandom 特殊字符，产生大量随机数
/dev/random 会一直封锁，直到填入的随机数够用
/dev/urandom 不会封锁，速度快
系统在正常关机下，进程的删除是以由大到小的进程ID依此执行，直到剩下init为止
当程序不正常终止时，可能会在文件系统离留下残余数据。这些数据本应删除，除了浪费空间外，还可能导致程序下次无法执行
只列出目录：
ls -ld */
ls -la | grep '^d'
$# 是传给脚本的参数个数
$0 是脚本本身的名字
$1 是传递给该shell脚本的第一个参数
$2 是传递给该shell脚本的第二个参数
$@ – 以 $IFS 为分隔符列出所有传递到脚本中的参数
$* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个
$$ 是脚本运行的当前进程ID号
$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误
basename $0 只返回脚本名
$*变量会将所有的参数当成单个参数，而$@变量会单独处理每个参数。
inode 表格大小为文件系统安装时就已固定，所以文件系统即使仍有空间置放文件数据，也可能出现已满的状态
linux查看已挂载分区的当前挂载参数： cat /proc/mounts    参数详细
fstab中，分区挂载的defaults：rw,suid,dev,exec,auto,nouser,async       
suid,允许suid命令生效   exec允许执行二进制文件  auto 可以用-a参数mount
nouser 禁止非root用户mount async I/O请求异步
atime:文件访问时间
mtime:文件内容修改时间
ctime:文件更改状态时间
写入文件，一定会改变mtime,ctime
chmod,chown等会改变ctime，不会改变mtime
文件夹的mtime,ctime,atime
文件夹中，有文件的新建和删除会改变mtime
文件夹中的文件ctime改变，文件夹的ctime就一起改变
文件夹下的文件列表或文件被访问，文件夹的atime就会改变
MBR主引导记录，位于硬盘的0道0面1扇区，大小512字节，MBR引导程序占446个字节
随后的64个是硬盘分区表，最后两个为分区结束标志
dd if=/dev/sda of=mbr bs=512 count=1
xxd mbr //xxd 是linux下的一个十六进制输出命令 yum install vim-common
pv 物理卷
pvscan 扫描pv
lvscan 扫描lv
重新调整分区大小以后，需要再次格式化。如果没有格式化，或者格式化的文件系统类型不对，swapon就会报错：Invalid argument
mkswap /dev/xxxx
swapon /dev/xxxx
swapoff /dev/xxx
linux 限制用户资源_限制单个制定用户或用户组资源的方法
vi /etc/security/limits.conf
每一行的用户限制格式为:<domain> <type> <item> <value>
1.domain 可以是一个用户名,一个以@开拓的用户组名，* 代表所有
2.type 可以是soft 和hard 
3.item 限制项
- core - limits the core file size (KB)
- data - max data size (KB)
- fsize - maximum filesize (KB)
- memlock - max locked-in-memory address space (KB)
- nofile - max number of open files
- rss - max resident set size (KB)
- stack - max stack size (KB)
- cpu - max CPU time (MIN)
- nproc - max number of processes
- as - address space limit
- maxlogins - max number of logins for this user
- maxsyslogins - max number of logins on the system
- priority - the priority to run user process with
- locks - max number of file locks the user can hold
- sigpending - max number of pending signals
- msgqueue - max memory used by POSIX message queues (bytes)
- nice - max nice priority allowed to raise to
- rtprio - max realtime priority
4.value 限制值 任意整数，或 unlimited
eg： shellcn soft    nofile    100
linux系统中，每当进程打开一个文件时，系统就为其分配一个唯一的整形文件描述符，用来标示这个文件
系统默认的最大文件描述符限制为1024    ulimit -a
web服务器等，可以通过在/etc/rc.d/rc.local文件中用 ulimit -Hsn 65536进行修改文件的描述符数
curl命令是linux shell下用来获取网页内容的常用命令,curl默认有个比较讨厌的功能，就是常常自动显示出统计信息
curl -s http://www.shellcn.net|grep abc   //-s 静默模式
用ls 按照mtime,ctime,atime对文件进行排序，分别对应tl,ctl,utl
man 命令数组说明：
1.通用命令(General Commands)
2.系统调用指令(System Calls)
3.子程序(Subroutines)
4.特殊文件(Special Files)
5.文件格式(File Formats)
6.游戏(Games)
7.宏和协议(Macros and Conventions)
8.系统维护命令(Maintenence Commands)
linux中的资源限制分为软限制和硬限制，ulimit 硬限制一旦设置就不能增加，软限制能够最多增加到硬限制的值。
ls -l 七个字段的说明：
权限,硬链接数或目录的子目录数，所有者，所属用户组,文件大小byte，mtime（修改时间，最后一次写文件内容时间）,文件名
扩展正则表达式与基础正则表达式的唯一区别在于：? + () {} 这几个字符 ，扩展正则表达式与基础正则表达式的区别，就是它们加不加转义符号，代表的意思刚好相反。
=~符号在shell条件判断中，用来表示是否匹配。=~右边是正则表达式，=~左边是被匹配的字符串
str=www.shellcn.net
if [[ "$str"  =~ shellcn.net$ ]]
then
echo matched
fi
=~右侧的正则表达式不能被引号括起来，否则将不会得到正确结果。
请牢记=~的使用格式。任何格式的错误都会导致匹配功能的失效。
=~是shell中的匹配符号，=~左侧的变量最好加引号，右侧的为正则表达式，正则表达式上不能加引号，加了引号正则就没用了，当字符串处理了
匹配空行，shell脚本实现：    [[ str1 =~ str1 ]] 这个就是正则匹配啊，str1 和普通的字符串一样，不使用//来表示正则
cat 1.txt |while read line
do if [[ "$line" =~ ^$ ]]
then echo 空行
fi
done
[ ] 实际上是bash 中 test 命令的简写。即所有的 [ expr ] 等于 test expr
[[ expr ]] 是bash中真正的条件判断语句
在 [[ 中使用 && 和 || 
[ 中使用 -a 和 -o 表示逻辑与和逻辑或。
[[ 中可以使用通配符
arch=i486 
[[ $arch = i*86 ]] && echo "arch is x86!" 
[[ 中匹配字符串或通配符，不需要引号
用grep -c来统计匹配到的字符的行数 
1. [[ `grep -c "test" test` -eq 0 ]] && echo "OK"  
 2.   $coun=`grep -c "test" test`
        if [ $coun -eq 0 ];then
            echo "OK"
        fi
命令1和2是等价的
-gt,-lt是算数比较操作
> < == 是字符比较操作
== 用于字符串比较
=    用于字符串赋值
-eq 等于,如:if [ "$a" -eq "$b" ]  
-ne 不等于,如:if [ "$a" -ne "$b" ]  
-gt 大于,如:if [ "$a" -gt "$b" ]  
-ge 大于等于,如:if [ "$a" -ge "$b" ]  
-lt 小于,如:if [ "$a" -lt "$b" ]  
-le 小于等于,如:if [ "$a" -le "$b" ]  
<   小于(需要双括号),如:(("$a" < "$b"))  
<=  小于等于(需要双括号),如:(("$a" <= "$b"))  
>   大于(需要双括号),如:(("$a" > "$b"))  
>=  大于等于(需要双括号),如:(("$a" >= "$b")) 
f1 -nt f2                   文件f1是否比f2新
f1 -ot f2                   文件f1是否比f2旧
f1 -ef f2                   文件f1和f2是否硬连接到同一个文件
在使用数值比较的时候，用(())，减少出错
"["：    逻辑与："-a"；逻辑或："-o"；
"[["：    逻辑与："&&"；逻辑或："||"
$ [[ 99+1 -eq 100 ]]&&echo true||echo false
true
$ [ $((99+1)) -eq 100 ]&&echo true||echo false
true
linux系统中，通配符一般只应用于文件名的匹配 ? * [a-z] [0-9] [!a]
ls *.txt #匹配txt结尾的文件
ls [0-9]*.txt #匹配0-9开头的,.txt结尾的文件
ls [!1].txt #匹配不是1开头的只有一位字符的txt文件，如a.txt 3.txt
ls -a| awk '$1~/^\./ {print $1}'
~：awk正则表达式的匹配运算符
echo 默认会自动换行的
[root@shellcn.net ~#] echo -e "linux\c";echo shell
linuxshell
\c 反斜杠转义后的意思为：不产生额外的输出，即不产生额外的换行符
while read line
do
    echo $line
done < filename
cat >1.txt <<EOF   #将分界符EOF之间的文本输入到1.txt
A
B
C
EOF
head -n -1 shellcn.txt    //-number 可以直接实现打印 除最后指定行数 的所有行
xargs是一条Unix和类Unix操作系统的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题
//变量的变量引用
#!/bin/bash
a0="abc";
j=0
b="a"$j;
此时$b=a0;
如何利用b取a0的值？
echo ${!b}
until循环执行命令至到条件为true时停止执行，until循环与while循环相反。一般while循环优于until循环，但较少使用
until 测试条件; do 
语句1 语句2 ... 
done
while循环用于不断执行的一系统命令，也可以从文件中读取数据，大多数用于测试条件，while循环语法格式：
while 测试条件; do 
语句1 语句2 ... 
done
case … esac是一种多分枝选择结构，case语句匹配一个值或一个模式，如果匹配成功，执行相匹配的命令
每一个模式必须以括号结果，值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至遇见;;。“;;”号意思是跳到整个case语句的最后。取值将检测匹配的每一个模式，一旦模式匹配，则执行匹配模式相应的命令后不再继续其他模式，如果无一匹配模式，使用星号“*”捕获该值，再执行后面的命令
case 值 in
value1)
             语句1 
             ...
             ;; 
value2) 
            语句1 
            ... 
            ;; 
value3) 
            语句1 
            ...
            ;;
 *) 
            语句1 
            ... 
            ;; 
esac 
短路运算符操作；只要前半段已经可以决定最终结果，后半段就不会再执行运算
cmd1 && cmd2
        1.若cmd1执行完毕且正确执行($?=0),则开始执行cmd2
        2.若cmd1执行完毕但为错误($?！=0),则不执行cmd2
cmd1 || cmd2   
        1.若cmd1执行完毕且正确执行($?=0),则不执行cmd2
        2.若cmd1执行完毕但为错误($?！=0),则执行cmd2
字符测试语句：
>：大于 <：小于 如：if [ "$A \< "$B" ]注：在[]中"<"需要用"\"转义 ==：等于 如：if [ "$A" == "$B" ] =~：判断左加字符串是否能够被右边的模式匹配，大部分用用[[]]中。 [[ $A =~ $B ]] -z：为空则为真，不为空则为假 -n：为空则为假，不为空则为真
这个计算需要用的生成数字序列：seq [起始数字] [步长] 结束数字：如：seq 1 2 100：
odd=$[$odd+$I]    //数字
-s file    检测文件是否为空（文件大小是否大于0），不为空返回 true
-e file    检测文件（包括目录）是否存在，如果是，则返回 true
s_base_time=`ssh $ip "stat $path/homed_base/bin |tee | grep Modify | awk -F. '{print $'1'}'"`      //特殊
ssh $ip "stat $path/homed_base/bin |tee | grep Modify | awk -F. '{print \$1}'" //不赋值给变量
遍历目录
#!/bin/sh    
list_alldir(){    
    for file2 in `ls -A $1`    
    do    
        if [ -d "$1/$file2" ];then    
            echo "$1/$file2"    
          list_alldir "$1/$file2"    
         fi     
    done    
 }    
  list_alldir ./test 
----------------------------------------------------------------------------------------------------------------------
shell脚本 --if(数字条件，文件，字符串) 常用
整数比较：
-eq
-ne
-gt
-ge
-lt
-le
字符串比较：
==     //等于
=    //等于
！=    //不等于
-z    //字符串长度为0
-n    //字符串长度不为0
文件比较:
-e    //文件存在
-f    //普通文件
-s    //文件长度不为0
-d    //被测对象是目录
-b    //被测对象是块设备
-c    //被测对象是字符设备
-L    //被测文件是符号连接
-S    //被测文件是一个socket
-r    //文件具有读权限
-w    //写权限
-x    //执行权限
-o    //文件的所有者
-G    //文件的组
-N    //从文件最后被阅读到现在，是否被修改
f1 -nt f2    //文件f1是否比f2新
f1 -ot  f2    //文件f1是否比f2旧
----------------------------------------------------------------------------------------------------------------------
如何避免shell脚本被同时运行多次
#!/bin/bash
LOCK_NAME="/tmp/my.lock"
if ( set -o noclobber; echo "$$" > "$LOCK_NAME") 2> /dev/null;
then
trap 'rm -f "$LOCK_NAME"; exit $?' INT TERM EXIT
### 开始正常流程
### 正常流程结束
### Removing lock
rm -f $LOCK_NAME
trap - INT TERM EXIT
else
echo "Failed to acquire lockfile: $LOCK_NAME."
echo "Held by $(cat $LOCK_NAME)"
exit 1
fi
echo "Done."
 
set -o noclobber 的意思：
If set, bash does not overwrite an existing file with the >, >&, and <> redirection operators.
 
这样就能保证my.lock只能被一个进程创建出来。比touch靠谱多了。
trap 可以捕获各种信号，然后做出处理：
INT 用来处理 ctrl+c取消脚本执行的情况。
TERM 用来处理 kill -TERM pid 的情况。
`cat /etc/passwd`     $(cat /etc/passwd)    反引号和$()作用一样
----------------------------------------------------------------------------------------------------------------------
read
read命令接收标准输入（键盘）的输入，或其他文件描述符的输入（后面在说）。得到输入后，read命令将数据放入一个标准变量中。下面是 read命令

#!/bin/bash

echo -n "Enter your name:"   //参数-n的作用是不换行，echo默认是换行

read  name                   //从键盘输入

echo "hello $name,welcome to my program"     //显示信息

exit 0                       //退出shell程序。
由于read命令提供了-p参数，允许在read命令行中直接指定一个提示。
read -p "Enter your name:" name  等价于  echo -n "Enter your name:" read name 
在上面read后面的变量只有name一个，也可以有多个，这时如果输入多个数据，则第一个数据给第一个变量，第二个数据给第二个变量，如果输入数 据个数过多，则最后所有的值都给第一个变量。如果太少输入不会结束。
在read命令行中也可以不指定变量.如果不指定变量，那么read命令会将接收到的数据放置在环境变量REPLY中。
使用read命令存在着潜在危险。脚本很可能会停下来一直等待用户的输入。如果无论是否输入数据脚本都必须继续执行，那么可以使用-t选项指定一个 计时器。
-t选项指定read命令等待输入的秒数。当计时满时，read命令返回一个非零退出状态
if read -t 5 -p "please enter your name:" name
除了输入时间计时，还可以设置read命令计数输入的字符。当输入的字符数目达到预定数目时，自动退出，并将输入的数据赋值给变量。
read -n1 -p "Do you want to continue [Y/N]?" answer
-s选项能够使read命令中输入的数据不显示在监视器上（实际上，数据是显示的，只是 read命令将文本颜色设置成与背景相同的颜色）
每次调用read命令都会读取文件中的"一行"文本。当文件没有可读的行时，read命令将以非零状态退出。
读取文件的关键是如何将文本中的数据传送给read命令。
最常用的方法是对文件使用cat命令并通过管道将结果直接传送给包含read命令的 while命令
#!/bin/bash
count=1    //赋值语句，不加空格
cat test | while read line        //cat 命令的输出作为read命令的输入,read读到的值放在line中
do
   echo "Line $count:$line"
   count=$[ $count + 1 ]          //注意中括号中的空格。
done
echo "finish"
exit 0
eval命令将会首先扫描命令行进行所有的置换，然后再执行该命令。该命令适用于那些一次扫描无法实现其功能的变量。该命令对变量进行两次扫描。这些需要进行两次扫描的变量有时被称为复杂变量。不过这些变量本身并不复杂
eval命令也可以用于回显简单变量，不一定是复杂变量。
 eval temp="$""$srv"_ips
 list=`echo $temp | sed 's/ /\n/g' | sort -u`
首先我们首先创建一个名为test的小文件，在这个小文件中含有一些文本。接着，将cat test赋给变量myfile，现在我们e c h o该变量，看看是否能够执行上述命令。
[neau@mail ~]$ vi test
[neau@mail ~]$ cat test
Hello World!!!
I am a chinese Boy!
将cat testf赋给变量myfile
[neau@mail ~]$ myfile="cat test"
如果我们e c h o该变量，我们将无法列出t e s t 文件中的内容。
[neau@mail ~]$ echo $myfile
cat test
让我们来试一下e v a l命令，记住e v a l命令将会对该变量进行两次扫瞄。
[neau@mail ~]$ eval $myfile
Hello World!!!
I am a chinese Boy!
从上面的结果可以看出，使用e v a l命令不但可以置换该变量，还能够执行相应的命令。第
一次扫描进行了变量置换，第二次扫描执行了该字符串中 所包含的命令cat test
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
sed && awk
使用sed在一个文件的制定位置插入另一个文件的内容-r命令
在一个文件的指定位置，如匹配到一个单词的行的下一行插入另一个文件的全部内容，可以使用sed的r命令
sed '/test/r file' data    //在data文件中查找test字符，并在该行后插入file文件的全部内容
echo "1 2 3 4" | sed 's/ /\n/g'
eval temp="$""$srv"_ips
list=`echo $temp | sed 's/ /\n/g' | sort -u`
awk 中END是最后才执行的
cat grade.txt | awk '{sum=$2+$3+$4+$5+$6} {print $1,sum/5}' 
    执行过程是，每读取一行数据，进行计算一次，然后打印出来
cat grade.txt | awk '{sum=$2+$3+$4+$5+$6} END{print $1,sum/5}'
    执行过程是，数据会逐行被处理，但是只打印出最后一行
cat grade.txt | awk '{ sum=$2+$3+$4+$5+$6} {print $1,sum/5} END{print NR,"records"}'
cat grade.txt | awk 'BEGIN{print "name","avg"} {sum=$2+$3+$4+$5+$6} {print $1,sum/5} END{print NR,"records"}'
    BEGIN用户在报表的开头打印，仅执行一次
    END最后执行的，仅执行一次
awk 中 print输出指定内容后换行，printf只输出指定内容后不换行
awk默认是以行为单位处理文本的，对1.txt中的每一行都执行后面 "{ }" 中的语句。
awk中的两个术语：
记录（默认就是文本的每一行）
字段 （默认就是每个记录中由空格或TAB分隔的字符串）
$0就表示一个记录，$1表示记录中的第一个字段
短程序通常直接在命令行上提供，比较长的程序通常委托-f选项指定
RS ORS FS OFS的区别
RS和ORS是定义行的,RS是awk读取文件时的行分隔符，ORS则是awk输出时的行结束符。
默认，RS的值是\n
[root@slave30(130) /homed/ilogslave/config]# echo '1a2b3c' | awk '{print $1}'
1a2b3c
[root@slave30(130) /data1/wangdong]# echo '1ab2bc3cd4de5' | awk 'BEGIN{RS="[a-z]+"}{print $1,RS,RT}'
1 [a-z]+ ab
2 [a-z]+ bc
3 [a-z]+ cd
4 [a-z]+ de
5 [a-z]+ 
更简单的讲，就是awk在输出时，会在每行记录后面增加一个ORS变量所设定的值。
ORS的值只能设定为字符串，默认情况下，ORS的值是\n 
seq 5 | awk '{print $0}'
1
2
3
4
5
seq 5 | awk 'BEGIN{ORS="a"}{print $0}'
1a2a3a4a5a
FS和OFS是awk对列的操作
FS 的使用和 -F 一样
当我们想以固定的长度来分隔列的时候，可以使用 FIELDWIDTHS 来代替 FS
FS是awk读入记录时的列分隔符，OFS则是awk输出时的列分隔符
[root@master(47.141) /homed]# echo '1 2' | awk -v OFS="------------" '{print $1,$2}'
1------------2
awk中的“真”与“假”。
以下3种情况是“假”，其他情况都为“真”
1) 数字 0
2) 空字符串
3) 未定义的值 

NR表示从awk开始执行后，按照记录分隔符读取的数据次数，默认的记录分隔符为换行符，因此默认的就是读取的数据行数，NR可以理解为Number of Record的缩写。

在awk处理多个输入文件的时候，在处理完第一个文件后，NR并不会从1开始，而是继续累加，因此就出现了FNR，每当处理一个新文件的时候，FNR就从1开始计数，FNR可以理解为File Number of Record。

NF表示目前的记录被分割的字段的数目，NF可以理解为Number of Field。
awk '{print NR,$0}' /etc/passwd    //打印出内容，并加上行号
awk -F':' 'NR>3&&NR<6 {print NR,$0}' /etc/passwd
awk -F':' -v OFS='--------------' 'NR<3 {print $1,$2}' /etc/passwd
awk '{print FILENAME,"NR="NR,"FNR="FNR,"$"NF"="$NF}' /etc/passwd
next 和getline
[root@slave30(130)]# echo "1 2 3 4 " | awk '{print $1;next;print $2}'
1
[root@slave30(130)]# echo "1 2 3 4 " | awk '{print $1;getline;print $2}'    
1
2
next只是完成当前记录的处理，继续处理下一条记录（上面的代码里print $2根本执行不到）
getline是读取下一条记录以后继续执行后面的print $2
awk '{if(NR==1){next} print $1,$2}' data //awk的next忽略掉第一行即可。
与next相似，getline也是读取下一行数据。但是与next不同的是，next读取下一行之后，把控制权交给了awk脚本的顶部。但是getline却没有改变脚本的控制，读取下一行之后，继续运行当前的awk脚本。getline执行之后，会覆盖$0的内容。
除了读取本文间的 下一行，getline还能够读取其他文件
awk 'NF=5 ~ /test/ {print $1","$6}'    //将第五个字段的值与正则表达式"test" 比较
NF ==5 && NR>1 //表示字段的数量必须等于5并且记录的编号大于1
awk 中!a[$0]++    和!a[$1...]++     !优先级高于++ 
!a[$0]++ 去除一行中重复的记录
!a[$1]++可以根据记录中某个域删除这个域相同的记录，也可以根据这个域相同，执行另外一些相应的操作
awk '{++a[$1]} END{for(i in a)print i "\t" a[i] }' access_log
统计（按域统计）文件中某个域出现的次数，有时候可能根据日志中的IP地址来统计某个IP访问网站的次数
cat /usr/local/apache/conf/httpd.conf | awk '/^$/{++x} END{print x}'    /统计出空行的数量
awk有三种循环:while循环；for循环；special for循环。
$ awk '{ i = 1; while ( i <= NF ) { print NF,$i; i++}}' test
$ awk '{for (i = 1; i<NF; i++) print NF,$i}' test 作用同上
变量的初始值为1，若i小于可等于NF(记录中域的个数),则执行打印语句，且i增加1。直到i的值大于NF.
breadkcontinue语句。break用于在满足条件的情况下跳出循环；continue用于在满足条件的情况下忽略后面的语句，直接返回循环的顶端。如：
{for ( x=3; x<=NF; x++) if ($x<0 ){print "Bottomed out!"; break   }}
{for ( x=3; x<=NF; x++) if ($x==0){print "Get next item"; continue}}      
next语句从输入文件中读取一行，然后从头开始执行awk脚本。如：
{if ($1 ~/test/){next}    else {print}}    
exit语句用于结束awk程序，但不会略过END块。退出状态为0代表成功，非零值表示出错
 cat grade.txt | awk '{sum=0;for(i=2;i<=NF;i++) sum=sum+$i}{print sum/5}'    
cat grade.txt | awk -v OFS="---" '{sum=0;for(i=2;i<=NF;i++) sum=sum+$i}{print $1,sum/5}'
当应用多个输入文件时，变量FNR被用来表示与当前输入文件相关的当前记录的代码
格式化打印
printf( "%d\t%s\n",$5,$9)
%-20s //左对齐，20个字符的宽度
printf("|%10s|\n","hello")

